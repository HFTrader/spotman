#!/usr/bin/env python3
"""
SpotMan - AWS EC2 Instance Manager
A comprehensive tool for managing AWS EC2 instances with application class tagging.
Frontend script that uses the SpotMan core library.
"""

import argparse
import sys
import time
from typing import Dict, List

# Import the core functionality
from spotman_core import AWSInstanceManager


def format_instances_table(instances: List[Dict]) -> None:
    """Format and print instances in a table."""
    if not instances:
        print("No instances found.")
        return

    # Check if Region column is present
    has_region = any('Region' in inst for inst in instances)

    if has_region:
        headers = ['Name', 'Instance ID', 'Type', 'State', 'Region', 'Public IP', 'App Class', 'Profile']
    else:
        headers = ['Name', 'Instance ID', 'Type', 'State', 'Public IP', 'App Class', 'Profile']

    # Calculate column widths
    widths = [len(h) for h in headers]
    for instance in instances:
        idx = 0
        widths[idx] = max(widths[idx], len(instance['Name'])); idx += 1
        widths[idx] = max(widths[idx], len(instance['InstanceId'])); idx += 1
        widths[idx] = max(widths[idx], len(instance['InstanceType'])); idx += 1
        widths[idx] = max(widths[idx], len(instance['State'])); idx += 1
        if has_region:
            widths[idx] = max(widths[idx], len(instance.get('Region', ''))); idx += 1
        widths[idx] = max(widths[idx], len(instance['PublicIpAddress'])); idx += 1
        widths[idx] = max(widths[idx], len(instance['ApplicationClass'])); idx += 1
        widths[idx] = max(widths[idx], len(instance['Profile']))

    # Print header
    header_line = ' | '.join(h.ljust(w) for h, w in zip(headers, widths))
    print(header_line)
    print('-' * len(header_line))

    # Print instances
    for instance in instances:
        if has_region:
            row = [
                instance['Name'].ljust(widths[0]),
                instance['InstanceId'].ljust(widths[1]),
                instance['InstanceType'].ljust(widths[2]),
                instance['State'].ljust(widths[3]),
                instance.get('Region', '').ljust(widths[4]),
                instance['PublicIpAddress'].ljust(widths[5]),
                instance['ApplicationClass'].ljust(widths[6]),
                instance['Profile'].ljust(widths[7])
            ]
        else:
            row = [
                instance['Name'].ljust(widths[0]),
                instance['InstanceId'].ljust(widths[1]),
                instance['InstanceType'].ljust(widths[2]),
                instance['State'].ljust(widths[3]),
                instance['PublicIpAddress'].ljust(widths[4]),
                instance['ApplicationClass'].ljust(widths[5]),
                instance['Profile'].ljust(widths[6])
            ]
        print(' | '.join(row))

    print(f"\nTotal: {len(instances)} instance(s)")


def format_profiles_table(profiles: List[str], manager: AWSInstanceManager) -> None:
    """Format and print profiles in a table."""
    if not profiles:
        print("No profiles found.")
        return
    
    print("Available Profiles:")
    print("=" * 50)
    
    for profile_name in profiles:
        try:
            profile = manager.get_profile(profile_name)
            if profile:
                instance_type = profile.get('instance_type', 'Not specified')
                spot_instance = profile.get('spot_instance', False)
                hibernation = profile.get('hibernation_enabled', False)
                os_type = profile.get('os_type', 'ubuntu')
                
                print(f"\nðŸ“‹ {profile_name}")
                print(f"   Instance Type: {instance_type}")
                print(f"   OS Type: {os_type}")
                print(f"   Spot Instance: {'âœ… Yes' if spot_instance else 'âŒ No'}")
                print(f"   Hibernation: {'âœ… Yes' if hibernation else 'âŒ No'}")
                
                # Show port forwarding if configured
                port_forwards = profile.get('ssh_port_forwards', [])
                if port_forwards:
                    print(f"   Port Forwarding:")
                    for forward in port_forwards:
                        local_port = forward.get('local_port')
                        remote_port = forward.get('remote_port', local_port)
                        remote_host = forward.get('remote_host', 'localhost')
                        print(f"     {local_port} -> {remote_host}:{remote_port}")
                
                # Show application class if specified
                app_class = profile.get('tags', {}).get('ApplicationClass')
                if app_class:
                    print(f"   Default App Class: {app_class}")
            else:
                print(f"\nâŒ {profile_name} (Error loading)")
        except Exception as e:
            print(f"\nâŒ {profile_name} (Error: {e})")
    
    print(f"\nTotal: {len(profiles)} profile(s)")


def main():
    """Main entry point for SpotMan CLI."""
    parser = argparse.ArgumentParser(
        description='SpotMan - AWS EC2 Instance Manager with Application Class Support',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s create --profile web-server --alias web01 --class web
  %(prog)s create --profile spot-hibernation --alias spot01 --class spot
  %(prog)s list --class web --state running
  %(prog)s start web01
  %(prog)s stop web01
  %(prog)s hibernate spot01
  %(prog)s resume spot01
  %(prog)s update-ssh --class web
  %(prog)s terminate web01
  %(prog)s list-profiles
        """
    )
    
    parser.add_argument('--region', help='AWS region')
    parser.add_argument('--aws-profile', help='AWS profile to use')
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Create command
    create_parser = subparsers.add_parser('create', help='Create a new instance')
    create_parser.add_argument('--profile', required=True, help='Profile to use')
    create_parser.add_argument('--alias', help='Instance alias (default: profile-YYYYMMDD-HHMMSS)')
    create_parser.add_argument('--class', help='Application class tag')
    create_parser.add_argument('--az', help='Availability zone (e.g., us-east-1a)')
    create_parser.add_argument('--spot-price', type=float, help='Maximum spot price')
    create_parser.add_argument('--spot', action='store_true', help='Force spot instance (override profile)')
    create_parser.add_argument('--on-demand', action='store_true', help='Force on-demand instance (override profile)')
    create_parser.add_argument('--dry-run', action='store_true', help='Validate without creating')
    
    # List command
    list_parser = subparsers.add_parser('list', help='List instances')
    list_parser.add_argument('--class', help='Filter by application class')
    list_parser.add_argument('--state', help='Filter by state')
    list_parser.add_argument('--profile', help='Filter by profile')
    list_parser.add_argument('--all', action='store_true', help='Show all instances, not just spotman-created ones')
    
    # Start command
    start_parser = subparsers.add_parser('start', help='Start an instance')
    start_parser.add_argument('instance', help='Instance name or ID')
    
    # Stop command
    stop_parser = subparsers.add_parser('stop', help='Stop an instance')
    stop_parser.add_argument('instance', help='Instance name or ID')
    
    # Hibernate command
    hibernate_parser = subparsers.add_parser('hibernate', help='Hibernate an instance')
    hibernate_parser.add_argument('instance', help='Instance name or ID')
    
    # Resume command
    resume_parser = subparsers.add_parser('resume', help='Resume a hibernated instance')
    resume_parser.add_argument('instance', help='Instance name or ID')
    
    # Terminate command
    terminate_parser = subparsers.add_parser('terminate', help='Terminate an instance')
    terminate_parser.add_argument('instance', help='Instance name or ID')
    
    # Hibernation status command
    status_parser = subparsers.add_parser('hibernation-status', help='Check hibernation status')
    status_parser.add_argument('instance', help='Instance name or ID')
    
    # Update SSH command
    ssh_parser = subparsers.add_parser('update-ssh', help='Update SSH configuration')
    ssh_parser.add_argument('--instance', help='Specific instance to update')
    ssh_parser.add_argument('--class', help='Update instances with this application class')
    ssh_parser.add_argument('--profile', help='Update instances with this profile')
    
    # List profiles command
    profiles_parser = subparsers.add_parser('list-profiles', help='List available profiles')

    # Status command (spot instance status and interruption info)
    status_parser2 = subparsers.add_parser('status', help='Show spot instance status and interruption info')
    status_parser2.add_argument('instance', help='Instance name or ID')

    # Price command (current spot prices)
    price_parser = subparsers.add_parser('price', help='Show current spot prices')
    price_parser.add_argument('--profile', help='Get price for instance type in profile')
    price_parser.add_argument('--instance-type', action='append', dest='instance_types',
                              help='Instance type(s) to query (can be repeated)')
    price_parser.add_argument('--az', help='Specific availability zone')

    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    # Initialize the manager
    try:
        manager = AWSInstanceManager(region=args.region, profile=args.aws_profile)
    except Exception as e:
        print(f"Error initializing SpotMan: {e}")
        sys.exit(1)
    
    # Execute commands
    if args.command == 'create':
        # Infer region from AZ if provided and no region specified
        if args.az and not args.region:
            inferred_region = args.az[:-1]
            manager = AWSInstanceManager(region=inferred_region, profile=args.aws_profile)

        # Generate instance name if not provided
        instance_name = args.alias
        if not instance_name:
            timestamp = time.strftime('%Y%m%d-%H%M%S')
            instance_name = f"{args.profile}-{timestamp}"
            print(f"Using generated name: {instance_name}")

        app_class = getattr(args, 'class', None)
        if not app_class:
            print("Warning: No application class specified. Use --class or add it to the profile.")

        # Determine spot override
        spot_override = None
        if args.spot and args.on_demand:
            print("Error: Cannot specify both --spot and --on-demand")
            sys.exit(1)
        elif args.spot:
            spot_override = True
        elif args.on_demand:
            spot_override = False

        instance_id = manager.create_instance(
            args.profile,
            instance_name,
            app_class,
            args.spot_price,
            args.dry_run,
            args.az,
            spot_override=spot_override
        )

        if instance_id and not args.dry_run:
            print(f"Instance created: {instance_id}")
    
    elif args.command == 'list':
        app_class = getattr(args, 'class', None)
        all_instances = []

        # Determine regions to query
        if args.region:
            regions_to_query = [args.region]
        else:
            regions_to_query = list(manager.regions_config.get('regions', {}).keys())
            if not regions_to_query:
                regions_to_query = [manager.region]

        # Query each region
        for region in regions_to_query:
            if region == manager.region:
                region_manager = manager
            else:
                region_manager = AWSInstanceManager(region=region, profile=args.aws_profile, quiet=True)

            instances = region_manager.list_instances(
                app_class=app_class,
                state=args.state,
                profile_name=args.profile,
                all_instances=args.all
            )
            # Add region info to each instance
            for inst in instances:
                inst['Region'] = region
            all_instances.extend(instances)

        format_instances_table(all_instances)
    
    elif args.command == 'start':
        manager.start_instance(args.instance)
    
    elif args.command == 'stop':
        manager.stop_instance(args.instance)
    
    elif args.command == 'hibernate':
        manager.hibernate_instance(args.instance)
    
    elif args.command == 'resume':
        manager.resume_hibernated_instance(args.instance)
    
    elif args.command == 'terminate':
        manager.terminate_instance(args.instance)
    
    elif args.command == 'hibernation-status':
        manager.check_hibernation_status(args.instance)
    
    elif args.command == 'update-ssh':
        app_class = getattr(args, 'class', None)
        manager.update_ssh_config(
            instance_id=args.instance,
            profile_name=args.profile,
            app_class=app_class
        )
    
    elif args.command == 'list-profiles':
        profiles = manager.list_profiles()
        format_profiles_table(profiles, manager)

    elif args.command == 'status':
        manager.get_spot_instance_status(args.instance)

    elif args.command == 'price':
        instance_types_queried = []

        # Determine instance types to query
        if args.profile:
            profile = manager.get_profile(args.profile)
            if profile:
                instance_type = profile.get('instance_type')
                if instance_type:
                    instance_types_queried.append(instance_type)
                else:
                    print(f"Profile {args.profile} does not specify an instance type")
                    sys.exit(1)
            else:
                print(f"Profile {args.profile} not found")
                sys.exit(1)
        elif args.instance_types:
            instance_types_queried = args.instance_types
        else:
            # No profile or instance type specified - use all profiles
            all_profiles = manager.list_profiles()
            for profile_name in all_profiles:
                profile = manager.get_profile(profile_name)
                if profile:
                    instance_type = profile.get('instance_type')
                    if instance_type and instance_type not in instance_types_queried:
                        instance_types_queried.append(instance_type)
            if not instance_types_queried:
                print("No profiles with instance types found")
                sys.exit(1)

        # Determine regions to query
        if args.az:
            # Infer region from AZ (e.g., us-east-1a -> us-east-1)
            regions_to_query = [args.az[:-1]]
        elif args.region:
            regions_to_query = [args.region]
        else:
            # Query all configured regions
            regions_to_query = list(manager.regions_config.get('regions', {}).keys())
            if not regions_to_query:
                regions_to_query = [manager.region]

        # Query prices and capacity scores for each region
        all_prices = []
        all_capacity_scores = {}  # {region: {az: score}}
        multi_region = len(regions_to_query) > 1
        for region in regions_to_query:
            if region == manager.region:
                region_manager = manager
            else:
                region_manager = AWSInstanceManager(region=region, profile=args.aws_profile, quiet=True)
            prices = region_manager.get_spot_prices(instance_types_queried, args.az if args.az else None)
            all_prices.extend(prices)

            # Get capacity scores for this region
            capacity_scores = region_manager.get_spot_capacity_scores(instance_types_queried)
            if capacity_scores:
                all_capacity_scores[region] = capacity_scores

        if all_prices:
            # Sort by instance type, then by price
            all_prices.sort(key=lambda x: (x['instance_type'], x['spot_price']))

            print("\nCurrent Spot Prices:")
            print("=" * 70)

            # Helper to format capacity score
            def format_capacity(az: str) -> str:
                # Find the region for this AZ
                region = az[:-1]  # e.g., us-east-1a -> us-east-1
                if region in all_capacity_scores and az in all_capacity_scores[region]:
                    score = all_capacity_scores[region][az]
                    if score >= 8:
                        indicator = "+++"  # High capacity
                    elif score >= 5:
                        indicator = "++"   # Medium capacity
                    elif score >= 3:
                        indicator = "+"    # Low capacity
                    else:
                        indicator = "-"    # Very low capacity
                    return f" [capacity: {score}/10 {indicator}]"
                return ""

            # Group by instance type
            current_type = None
            for p in all_prices:
                if p['instance_type'] != current_type:
                    current_type = p['instance_type']
                    print(f"\nðŸ“¦ {current_type}")
                capacity_info = format_capacity(p['availability_zone'])
                print(f"   {p['availability_zone']}: ${p['spot_price']:.4f}/hr{capacity_info}")

            # Print capacity legend if we have scores
            if all_capacity_scores:
                print("\nðŸ“Š Capacity Score Legend: 10=high likelihood, 1=low likelihood")
                print("   +++ (8-10): Excellent | ++ (5-7): Good | + (3-4): Fair | - (1-2): Poor")
        else:
            print(f"No spot prices found for: {', '.join(instance_types_queried)}")


if __name__ == '__main__':
    main()